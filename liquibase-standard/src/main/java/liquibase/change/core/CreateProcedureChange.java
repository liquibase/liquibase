package liquibase.change.core;

import liquibase.ChecksumVersion;
import liquibase.change.*;
import liquibase.database.Database;
import liquibase.database.DatabaseList;
import liquibase.database.core.*;
import liquibase.exception.DatabaseException;
import liquibase.exception.ValidationErrors;
import liquibase.statement.SqlStatement;
import liquibase.statement.core.CreateProcedureStatement;
import lombok.Setter;

import java.util.Map;

@DatabaseChange(name = "createProcedure", description = "Defines a stored procedure.", priority = ChangeMetaData.PRIORITY_DEFAULT)
public class CreateProcedureChange extends AbstractSQLAndFileChange implements DbmsTargetedChange {
    @Setter
    private String comment;

    @Setter
    private String procedureName;

    private String dbms;

    @Override
    public boolean generateRollbackStatementsVolatile(Database database) {
        return false;
    }

    @DatabaseChangeProperty(exampleValue = "new_customer",
        description = "Name of the stored procedure to create. Required if replaceIfExists=true")
    public String getProcedureName() {
        return procedureName;
    }

    @DatabaseChangeProperty(
        description = "File containing the procedure text. You must either use this attribute or write inline SQL within the createProcedure definition.",
        exampleValue = "com/example/my-logic.sql"
    )
    public String getPath() {
        return file();
    }

    @DatabaseChangeProperty(serializationType = SerializationType.DIRECT_VALUE, version = {ChecksumVersion.V8})
    @DatabaseChangeProperty(isChangeProperty = false)
    /**
     * @deprecated Use getProcedureText() instead
     */
    @Deprecated
    public String getProcedureBody() {
        return sql();
    }

    /**
     * @deprecated Use setProcedureText() instead
     */
    @Deprecated
    public void setProcedureBody(String procedureText) {
        sql( procedureText );
    }

    private final String procedureTextDescription = "The SQL creating the procedure. You need to define either this attribute or 'path'. " +
            "procedureText is not supported in the XML format; however, you can specify the procedure SQL inline within the createProcedure definition.";

    @DatabaseChangeProperty(
        description = procedureTextDescription,
            isChangeProperty = false, version = {ChecksumVersion.V8})
    @DatabaseChangeProperty(
        description = procedureTextDescription,
            serializationType = SerializationType.DIRECT_VALUE,
            alternatePropertyNames = {"procedureBody"})
    public String getProcedureText() {
        return sql();
    }

    public void setProcedureText(String s) {
        sql(s);
    }

    @Override
    @DatabaseChangeProperty(
        exampleValue = "h2, oracle",
        since = "3.1",
        description = "Specifies which database type(s) a changeset is to be used for. " +
        "See valid database type names on Supported Databases docs page. Separate multiple databases with commas. " +
        "Specify that a changeset is not applicable to a particular database type by prefixing with !. " +
        "The keywords 'all' and 'none' are also available."
    )
    public String getDbms() {
        return dbms;
    }

    @Override
    public void setDbms(final String dbms) {
        this.dbms = dbms;
    }

    @DatabaseChangeProperty(description = "Inline comments generated by update-sql. Not applied to the database")
    public String getComment() {
        return comment;
    }

    @DatabaseChangeProperty(description = "If the stored procedure defined by createProcedure already exists, " +
        "alter it instead of creating it. Default: false")
    public Boolean getReplaceIfExists() {
        return replaceIfExists;
    }

    @Override
    protected String sqlFieldName() {
        return "procedureText";
    }

    @Override
    public ValidationErrors validate(Database database) {
        // Not falling back to default because of path/procedureText option group. Need to specify everything.
        ValidationErrors validate = super.validate(database, new ValidationErrors(this));
        validate.checkDisallowedField("catalogName", this.getCatalogName(), database, MSSQLDatabase.class);
        if(getDbms() != null) {
            DatabaseList.validateDefinitions(getDbms(), validate);
        }

        if ((this.getReplaceIfExists() != null) && (DatabaseList.definitionMatches(getDbms(), database, true))) {
            if (databaseSupportsReplaceIfExists(database)) {
                if (this.getReplaceIfExists() && (this.getProcedureName() == null)) {
                    validate.addError("procedureName is required if replaceIfExists = true");
                }
            } else {
                validate.checkDisallowedField("replaceIfExists", this.getReplaceIfExists(), database);
            }
        }
        return validate;
    }

    /**
     * Listing SQL content fields (for example procedureText, triggerBody, etc.) we don't want to include as part of
     * the checksum computes, because have a separate part that computes that checksum for that part doing the
     * "normalizing" logic, so it is not impacted by the reformatting of the SQL. We are also excluding fields from the
     * checksum generation which does not have a direct impact on the DB, such as dbms, path, comments, etc.
     *
     * Besides it has an impact on the DB, we have decided to do not add replaceIfExists as part of this list of fields
     * as we are already avoiding the recalculation of the checksum by listing the main content fields of the different
     * change types.
     */
    @Override
    public String[] getExcludedFieldFilters(ChecksumVersion version) {
        if (version.lowerOrEqualThan(ChecksumVersion.V8)) {
            return new String[0];
        }
        return new String[]{
                "path",
                "dbms",
                "relativeToChangelogFile",
                "procedureText",
                "encoding",
                "comment",
                "triggerBody",
                "functionBody",
                "packageText",
                "packageBodyText"
        };
    }

    @Override
    public SqlStatement[] generateStatements(Database database) {
        String endDelimiter = ";";
        if (database instanceof OracleDatabase) {
            endDelimiter = "\n/";
        } else if (database instanceof AbstractDb2Database) {
            endDelimiter = "";
        }
        return generateStatements(getSqlText(), endDelimiter, database);
    }

    protected SqlStatement[] generateStatements(String logicText, String endDelimiter, Database database) {
        CreateProcedureStatement statement =
            new CreateProcedureStatement(
                getCatalogName(),
                getSchemaName(),
                getProcedureName(),
                logicText,
                endDelimiter
            );
        statement.setReplaceIfExists(getReplaceIfExists());
        return new SqlStatement[]{
                statement,
        };
    }

    @Override
    public ChangeStatus checkStatus(Database database) {
        return new ChangeStatus().unknown("Cannot check createProcedure status");
    }

    @Override
    public String getConfirmationMessage() {
        return "Stored procedure created";
    }

    @SuppressWarnings("java:S2095")
    @Override
    protected Map<String, Object> createExampleValueMetaData(
        String parameterName, DatabaseChangeProperty changePropertyAnnotation) {

        if ("procedureText".equals(parameterName) || "procedureBody".equals(parameterName)) {
            Map<String, Object> returnMap = super.createExampleValueMetaData(parameterName, changePropertyAnnotation);
            returnMap.put(
                new HsqlDatabase().getShortName(),
                "CREATE PROCEDURE new_customer(firstname VARCHAR(50), lastname VARCHAR(50))\n" +
                    "   MODIFIES SQL DATA\n" +
                    "   INSERT INTO CUSTOMERS (first_name, last_name) VALUES (firstname, lastname)"
            );

            return returnMap;
        } else {
            return super.createExampleValueMetaData(parameterName, changePropertyAnnotation);
        }
    }

    public static boolean databaseSupportsReplaceIfExists(Database database) {
        if (database instanceof MSSQLDatabase ||
                database instanceof MySQLDatabase ||
                database instanceof DB2Database ||
                database instanceof PostgresDatabase) {
            return true;
        }

        if (database instanceof Db2zDatabase) {
           try {
                int major = database.getDatabaseMajorVersion();
                if (major > 12) {
                    return true;
                }
                if (major < 12) {
                    return false;
                }
                return database.getDatabaseMinorVersion() >= 1;
            } catch (DatabaseException e) {
                return false;
            }
        }
        return false;
    }
}
